<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Luy·ªán T·∫≠p Pinyin</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Mulish:wght@400;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic CSS Reset & Base Styles - Tailwind handles most of this, but keeping specific fonts */
        body {
            font-family: 'Mulish', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 10px;
            overflow-x: hidden;
        }

        /* Specific font for Chinese characters if Noto Sans SC doesn't apply widely enough */
        .font-noto-sans-sc {
            font-family: 'Noto Sans SC', sans-serif;
        }
        
        .user-select-none {
            user-select: none;
        }

        .-webkit-tap-highlight-color-transparent {
            -webkit-tap-highlight-color: rgba(33, 150, 243, 0.3);
        }

        /* Custom animations (Tailwind JIT can handle these if configured) */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Responsive font sizes using clamp() need direct CSS or custom Tailwind config */
        .title {
            font-size: clamp(1.8em, 5vw, 2.5em);
        }
        .subtitle {
            font-size: clamp(0.9em, 3vw, 1.1em);
        }
        .practice-selector h3 {
            font-size: clamp(1em, 4vw, 1.2em);
        }
        .student-info label, .student-input, .practice-dropdown, .load-btn {
            font-size: clamp(1em, 3vw, 1.1em);
        }
        .loading, .error, .practice-info {
            font-size: clamp(0.9em, 3vw, 1em);
        }
        .action-btn {
            font-size: clamp(1em, 3vw, 1.1em);
        }
        .chinese-text-display {
            font-size: clamp(3em, 15vw, 5em);
        }
        .chinese-text-display.pinyin-font {
            font-size: clamp(1.8em, 8vw, 2.5em);
        }
        .meaning-display, .meaning-display.pinyin-font {
            font-size: clamp(1.1em, 4vw, 1.4em);
        }
        .audio-btn {
            width: clamp(45px, 12vw, 60px);
            height: clamp(45px, 12vw, 60px);
            font-size: clamp(1.2em, 4vw, 1.5em);
        }
        .result-title {
            font-size: clamp(1.8em, 5vw, 2.5em);
        }
        .result-btn {
            font-size: clamp(0.9em, 3vw, 1.1em);
        }
        .audio-status {
            font-size: clamp(0.8em, 2.5vw, 0.9em);
        }

        /* Custom classes for states (correct/incorrect/playing) that might have animations or complex styles */
        .pinyin-cell.correct {
            background-color: #d5f4e6;
            border-color: #27ae60;
            color: #27ae60;
            animation: correctPulse 0.8s ease-in-out;
        }

        .pinyin-cell.incorrect {
            background-color: #ffeaea;
            border-color: #e74c3c;
            color: #e74c3c;
            animation: incorrectShake 0.5s ease-in-out;
        }
        
        .audio-btn.playing {
            animation: pulse 1s infinite;
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .audio-btn.error {
            background: linear-gradient(135deg, #dc3545, #c82333);
            animation: none;
        }

        /* Media queries for mobile devices - Tailwind's responsive prefixes handle most of this */
        @media (max-width: 600px) {
            body {
                padding: 0;
            }
            .container {
                border-radius: 0;
                min-height: 100vh;
                padding: 15px;
                margin: 0;
            }
            /* Specific overrides for small screens if needed beyond Tailwind's defaults */
            .stat-item > div {
                 padding: 10px 15px; /* Reduce padding for stats on small screens */
            }
        }
        @media (max-width: 480px) {
            body {
                padding: 2px;
            }
            .container {
                padding: 10px;
                margin: 2px 0;
            }
            .practice-selector {
                padding: 10px;
            }
            .game-area {
                padding: 5px;
            }
            .pinyin-grid {
                gap: 10px;
            }
            .pinyin-cell {
                padding: 10px;
                font-size: 14px;
            }
        }
        /* Touch device optimizations (hover: none and pointer: coarse) */
        @media (hover: none) and (pointer: coarse) {
            .pinyin-cell:hover {
                border-color: #ecf0f1;
                transform: none;
                box-shadow: none;
            }
            .audio-btn:hover {
                transform: none;
                box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
            }
            button:hover, .action-btn:hover, .reset-btn:hover, .back-to-selection-btn:hover, .load-btn:hover {
                transform: none;
            }
            button, .pinyin-cell {
                min-height: 44px;
                min-width: 44px;
            }
            button:active, .pinyin-cell:active:not(.disabled) {
                opacity: 0.8;
                transform: scale(0.98);
            }
            /* Ensure animations work on touch devices */
            .pinyin-cell.correct {
                animation: correctPulse 0.8s ease-in-out !important;
            }
            .pinyin-cell.incorrect {
                animation: incorrectShake 0.5s ease-in-out !important;
            }
        }
    </style>
</head>
<body>
    <div class="container bg-white rounded-2xl p-5 shadow-xl max-w-xl w-full text-center relative overflow-hidden my-2 sm:p-4 sm:rounded-none sm:min-h-screen sm:flex sm:flex-col sm:justify-start sm:gap-4">
        <div class="header mb-5 sm:mb-0">
            <h1 class="title font-bold text-gray-800 mb-2 drop-shadow-md">üìù Luy·ªán T·∫≠p</h1>
        </div>

        <!-- Practice Selection Section -->
        <div class="practice-selector bg-gradient-to-br from-gray-50 to-gray-100 p-4 rounded-xl mb-5 sm:mb-0" id="practice-selector">
            <h3 class="mt-0 text-gray-700 font-semibold mb-5">üéØ Th√¥ng tin h·ªçc sinh v√† B√†i luy·ªán t·∫≠p:</h3>
            
            <!-- Student Name Input -->
            <div class="student-info mb-5 text-left">
                <label for="student-name" class="block text-gray-700 font-semibold mb-2">üë®‚Äçüéì T√™n h·ªçc sinh:</label>
                <input type="text" id="student-name" class="student-input w-full p-3 border-2 border-gray-300 rounded-lg text-base font-medium bg-white transition-all duration-300 focus:outline-none focus:border-indigo-500 focus:shadow-md placeholder:text-gray-500 placeholder:font-normal peer" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." maxlength="50">
            </div>
            
            <div class="dropdown-container flex items-center justify-center gap-2 flex-wrap sm:flex-col sm:gap-4">
                <select class="practice-dropdown p-3 border-2 border-gray-300 rounded-lg text-base font-semibold bg-white cursor-pointer transition-all duration-300 flex-1 min-w-[200px] max-w-[300px] hover:border-blue-500 hover:shadow-lg focus:outline-none focus:border-blue-500 focus:shadow-md sm:w-full sm:min-w-0 sm:max-w-none" id="practice-dropdown">
                    <option value="">Ch·ªçn b√†i luy·ªán t·∫≠p...</option>
                </select>
                <button class="load-btn bg-gradient-to-br from-blue-500 to-blue-700 text-white border-none py-3 px-5 rounded-full text-base cursor-pointer transition-all duration-300 font-semibold min-w-[120px] whitespace-nowrap -webkit-tap-highlight-color-transparent user-select-none hover:-translate-y-0.5 hover:shadow-lg disabled:bg-gray-400 disabled:cursor-not-allowed disabled:transform-none disabled:shadow-none sm:w-full sm:min-w-0" id="load-btn">üöÄ T·∫£i B√†i</button>
                <button class="btn btn-mode-toggle bg-gradient-to-br from-amber-400 to-amber-600 text-white py-3 px-6 rounded-lg text-base font-semibold cursor-pointer transition-all duration-300 uppercase tracking-wide hover:-translate-y-0.5 hover:shadow-lg sm:w-full" id="toggleDisplayModeBtn">‚öôÔ∏èCh·∫ø ƒë·ªô: Pinyin</button>
            </div>
            <div class="loading hidden mt-4 p-4 bg-yellow-100 border border-yellow-300 rounded-lg text-yellow-800 text-sm" id="loading">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu...</div>
            <div class="error hidden bg-red-100 text-red-700 border-2 border-red-500 rounded-lg p-4 mt-4 text-sm" id="error"></div>
            <div class="practice-info hidden mt-4 p-4 bg-blue-100 rounded-lg text-blue-700 text-sm" id="practice-info"></div>
        </div>

        <!-- Game Section -->
        <div class="game-section hidden" id="game-section">
            <div class="stats flex justify-center gap-2 mb-8 flex-nowrap p-4 bg-gray-50 rounded-xl sm:flex-row sm:justify-center sm:gap-1">
                <div class="stat-item flex-1 min-w-[120px] text-center">
                    <div class="p-4 rounded-xl bg-white shadow-sm">
                        <div class="stat-label text-xs text-gray-600 uppercase tracking-wide">ƒêi·ªÉm s·ªë</div>
                        <div class="stat-value text-2xl font-bold text-gray-800 mt-1" id="score">0</div>
                    </div>
                </div>
                <div class="stat-item flex-1 min-w-[120px] text-center">
                    <div class="p-4 rounded-xl bg-white shadow-sm">
                        <div class="stat-label text-xs text-gray-600 uppercase tracking-wide">Ti·∫øn ƒë·ªô</div>
                        <div class="stat-value text-2xl font-bold text-gray-800 mt-1" id="progress">0/0</div>
                    </div>
                </div>
                <div class="stat-item flex-1 min-w-[120px] text-center">
                    <div class="p-4 rounded-xl bg-white shadow-sm">
                        <div class="stat-label text-xs text-gray-600 uppercase tracking-wide">Ch√≠nh x√°c</div>
                        <div class="stat-value text-2xl font-bold text-gray-800 mt-1" id="accuracy">0%</div>
                    </div>
                </div>
            </div>

            <div class="progress-bar bg-gray-200 h-2 rounded-md mb-5 overflow-hidden">
                <div class="progress-fill h-full rounded-md transition-all duration-300 bg-gradient-to-r from-blue-500 to-emerald-500" id="progressFill"></div>
            </div>

            <div class="game-area mb-8 sm:p-1">
                <div class="current-word bg-blue-50 border-2 border-blue-400 rounded-xl p-5 mb-6">
                    <div class="current-word-label text-sm text-gray-600 mb-2">T·ª´ hi·ªán t·∫°i:</div>
                    <div class="chinese-text-display font-noto-sans-sc text-red-700 font-normal cursor-pointer transition-all duration-300 leading-none mb-2 hover:scale-110 hover:text-red-800" id="chineseTextDisplay">B·∫•m "B·∫Øt ƒë·∫ßu"</div>
                    <div class="meaning-display text-gray-700 mb-2 font-normal italic" id="meaningDisplay">ƒë·ªÉ ch∆°i</div>
                    <button class="audio-btn bg-gradient-to-br from-blue-500 to-blue-700 text-white border-none rounded-full flex items-center justify-center cursor-pointer transition-all duration-300 shadow-md mx-auto my-2 touch-action-manipulation hover:scale-110 hover:shadow-lg disabled:opacity-60 disabled:cursor-not-allowed disabled:transform-none" id="audioBtn" title="Ph√°t √¢m">üîä</button>
                    <div id="audio-status" class="audio-status hidden mt-2 p-2 rounded-lg text-sm"></div>
                </div>

                <div class="pinyin-grid grid grid-cols-3 gap-4 mb-6" id="pinyinGrid">
                    <!-- Pinyin cells will be generated by JavaScript -->
                </div>
            </div>

            <div class="controls flex gap-4 justify-center mb-5 flex-wrap sm:flex-col">
                <button class="btn btn-primary bg-blue-500 text-white py-3 px-6 rounded-lg text-base font-semibold cursor-pointer transition-all duration-300 uppercase tracking-wide flex-grow min-w-[120px] hover:bg-blue-700 hover:-translate-y-0.5" id="startBtn">B·∫Øt ƒë·∫ßu</button>
                <button class="btn btn-success bg-emerald-500 text-white py-3 px-6 rounded-lg text-base font-semibold cursor-pointer transition-all duration-300 uppercase tracking-wide flex-grow min-w-[120px] hover:bg-emerald-700 hover:-translate-y-0.5" id="newGameBtn" style="display: none;">L√†m l·∫°i</button>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div class="result-modal fixed inset-0 bg-black bg-opacity-50 hidden justify-center items-center z-50 p-2" id="resultModal">
        <div class="result-content bg-white p-10 rounded-2xl border-2 border-emerald-500 text-center max-w-lg w-full shadow-2xl relative overflow-hidden">
            <h2 class="result-title font-bold text-gray-800 mb-5"> <span class="text-indigo-500"></span></h2>
            <div class="text-base text-gray-700 mb-2">
                üìö <span id="finalPracticeName"></span>
            </div>
            <div class="text-sm text-gray-600 mb-4">
                üî¢ L·∫ßn n·ªôp: <span id="finalAttemptCount">0</span>
            </div>
            <div class="result-stats mb-8">
                <div class="result-stat mb-4">
                    <div class="result-stat-label text-sm text-gray-600">T·ªïng ƒëi·ªÉm</div>
                    <div class="result-stat-value text-3xl font-bold text-blue-500" id="finalScore">0</div>
                </div>
                <div class="result-stat mb-4">
                    <div class="result-stat-label text-sm text-gray-600">ƒê·ªô ch√≠nh x√°c</div>
                    <div class="result-stat-value" id="finalAccuracy">0%</div>
                </div>
                <div class="result-stat hidden">
                    <div class="result-stat-label">S·ªë l·∫ßn th·ª≠</div>
                    <div class="result-stat-value" id="totalAttempts">0</div>
                </div>
            </div>
            <div class="text-lg mb-2 text-emerald-600 font-semibold" id="personalMessage"></div>
            <div class="text-base mb-5" id="overallMessage"></div>

            <div class="result-buttons flex flex-col gap-2 mt-5">
                <button class="result-btn reset-btn bg-gradient-to-br from-amber-500 to-amber-700 text-white py-3 px-6 rounded-lg text-base cursor-pointer transition-all duration-300 font-semibold uppercase tracking-wide hover:-translate-y-0.5 hover:shadow-lg" id="modalResetBtn">üîÑ L√†m l·∫°i</button>
                <button class="result-btn back-to-selection-btn bg-gradient-to-br from-purple-600 to-purple-800 text-white py-3 px-6 rounded-lg text-base cursor-pointer transition-all duration-300 font-semibold uppercase tracking-wide hover:-translate-y-0.5 hover:shadow-lg" id="modalBackToSelectionBtn">üìö Ch·ªçn b√†i kh√°c</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration for practices and paths
        const CONFIG = {
            dataPath: 'data_pinyinPractice/', // Path to the directory containing lesson data
            practices: [
                { id: 'practice1', name: 'üìö Luy·ªán T·∫≠p 1' },
                { id: 'practice2', name: 'üìö Luy·ªán T·∫≠p 2' },
                { id: 'practice3', name: 'üìö Luy·ªán T·∫≠p 3 ' },
                { id: 'practice4', name: 'üìö Luy·ªán T·∫≠p 4 ' },
                { id: 'practice5', name: 'üìö Luy·ªán T·∫≠p 5 ' },
                { id: 'practice6', name: 'üìö Luy·ªán T·∫≠p 6 ' },
                { id: 'practice7', name: 'üìö Luy·ªán T·∫≠p 7 ' },
                { id: 'practice8', name: 'üìö Luy·ªán T·∫≠p 8 ' },
                { id: 'practice9', name: 'üìö Luy·ªán T·∫≠p 9 ' },
                { id: 'practice10', name: 'üìö Luy·ªán T·∫≠p 10 ' },
                { id: 'practice11', name: 'üìö Luy·ªán T·∫≠p 11 ' },
                { id: 'practice12', name: 'üìö Luy·ªán T·∫≠p 12 ' },
                { id: 'practice13', name: 'üìö Luy·ªán T·∫≠p 13 ' },
                { id: 'practice14', name: 'üìö Luy·ªán T·∫≠p 14 ' },
                { id: 'practice15', name: 'üìö Luy·ªán T·∫≠p 15 ' },
                { id: 'practice16', name: 'üìö Luy·ªán T·∫≠p 16 ' }
            ]
        };

        // Fallback demo data if file cannot be loaded
        // Structure: chinese|pinyin|meaning
        const demoData = {
            practice1: `‰Ω†Â•Ω|n«ê h«éo|xin ch√†o
Ë∞¢Ë∞¢|xi√® xi√®|c·∫£m ∆°n
ÂØπ‰∏çËµ∑|du√¨ bu q«ê|xin l·ªói
ÂÜçËßÅ|z√†i ji√†n|t·∫°m bi·ªát
Ê≤°ÂÖ≥Á≥ª|m√©i guƒÅn x√¨|kh√¥ng sao
ËØ∑ÈóÆ|q«êng w√®n|xin h·ªèi
‰∏çÂÆ¢Ê∞î|b√∫ k√® q√¨|kh√¥ng c√≥ g√¨
Â§öÂ∞ëÈí±|du≈ç sh«éo qi√°n|bao nhi√™u ti·ªÅn
ÊòéÂ§©ËßÅ|m√≠ng tiƒÅn ji√†n|h·∫πn g·∫∑p l·∫°i ng√†y mai`,
            practice2: `ÂÖ´|bƒÅ|t√°m
ÊÄï|p√†|s·ª£
È©¨|m«é|ng·ª±a
Âèë|fƒÅ|ph√°t
ÈÇ£|n√†|ƒë√≥
‰∏™|g√®|c√°i
ÂèØ|kƒõ|c√≥ th·ªÉ
Â§©|tiƒÅn|tr·ªùi
‰∏ç|b√π|kh√¥ng
ÂØπ|du√¨|ƒë√∫ng
Êúâ|y«íu|c√≥
‰ºö|hu√¨|bi·∫øt
ËØ¥|shu≈ç|n√≥i
ÂÅö|zu√≤|l√†m
ÊÉ≥|xi«éng|nghƒ©`,
            practice3: `Èó®|m√©n|c·ª≠a
ÈóÆ|w√®n|h·ªèi
Âæà|hƒõn|r·∫•t
Ë∑ü|gƒìn|v·ªõi
‰ªÄ|sh√©n|g√¨
‰πà|me|g√¨
Êó∂|sh√≠|th·ªùi
ÂÄô|h√≤u|l√∫c
Âπ¥|ni√°n|nƒÉm
Êúà|yu√®|th√°ng
Êó•|r√¨|ng√†y
im|jƒ´n|h√¥m
Êòé|m√≠ng|mai
Êò®|zu√≥|h√¥m qua
Áé∞|xi√†n|hi·ªán t·∫°i`
        };

        class PinyinGame {
            constructor() {
                this.allWords = []; // All words loaded from the file
                this.practiceWords = []; // The 9 randomly selected words for the current practice session
                
                // Initialize game state variables
                this.currentWordIndex = 0; // Index of the current word in the shuffled 'practiceWords' array
                this.score = 0; // Player's score
                this.correctAnswers = 0; // Number of correct answers
                this.totalAttempts = 0; // Total attempts (number of pinyin cell selections)
                this.gameStarted = false; // Game started state
                this.isPlaying = false; // Playing state (waiting for user to select pinyin)
                this.currentAudio = null; // Current Audio object
                this.studentName = ''; // Student's name
                this.currentPracticeId = ''; // Current practice ID
                this.attemptCount = 0; // Number of times the game has been completed

                // Display mode configuration
                this.displayModes = ['pinyin', 'meaning', 'chinese'];
                this.currentDisplayModeIndex = 0;
                this.displayMode = this.displayModes[this.currentDisplayModeIndex]; // Current display mode

                // Array to store data for the 9 pinyin cells on the grid. Each cell has pinyin and state (hidden/shown)
                this.gridPinyinCellsData = []; 

                // Initialize DOM elements
                this.initializeElements();
                // Set up event listeners
                this.setupEventListeners();
                // Initialize practice selection interface
                this.initializePracticeSelector();
                // Update initial display mode button text
                this.updateDisplayModeButtonText();
            }

            /**
             * Initializes references to DOM elements.
             */
            initializeElements() {
                try {
                    this.practiceSelector = document.getElementById('practice-selector');
                    this.studentNameInput = document.getElementById('student-name');
                    this.practiceDropdown = document.getElementById('practice-dropdown');
                    this.loadBtn = document.getElementById('load-btn');
                    this.loadingIndicator = document.getElementById('loading');
                    this.errorDisplay = document.getElementById('error');
                    this.practiceInfoDisplay = document.getElementById('practice-info');
                    this.gameSection = document.getElementById('game-section');

                    this.scoreElement = document.getElementById('score');
                    this.progressElement = document.getElementById('progress');
                    this.accuracyElement = document.getElementById('accuracy');
                    this.progressFillElement = document.getElementById('progressFill');
                    this.chineseTextDisplay = document.getElementById('chineseTextDisplay');
                    this.meaningDisplay = document.getElementById('meaningDisplay');
                    this.audioBtn = document.getElementById('audioBtn');
                    this.audioStatus = document.getElementById('audio-status');
                    this.pinyinGridElement = document.getElementById('pinyinGrid');
                    this.startBtn = document.getElementById('startBtn');
                    this.newGameBtn = document.getElementById('newGameBtn');
                    this.toggleDisplayModeBtn = document.getElementById('toggleDisplayModeBtn'); // Mode toggle button
                    
                    this.resultModal = document.getElementById('resultModal');
                    // Removed console.log for cleaner
                    if (!this.resultModal) {
                        console.error('L·ªói: Ph·∫ßn t·ª≠ resultModal kh√¥ng t√¨m th·∫•y!');
                    }

                    // Ensure resultModal is not null before querying its children
                    if (this.resultModal) {
                        this.resultTitle = this.resultModal.querySelector('.result-title span');
                        // Removed console.log for cleaner output, kept error check
                        if (!this.resultTitle) console.error('L·ªói: resultTitle kh√¥ng t√¨m th·∫•y!');
                        this.finalPracticeName = document.getElementById('finalPracticeName');
                        if (!this.finalPracticeName) console.error('L·ªói: finalPracticeName kh√¥ng t√¨m th·∫•y!');
                        this.finalAttemptCount = document.getElementById('finalAttemptCount');
                        if (!this.finalAttemptCount) console.error('L·ªói: finalAttemptCount kh√¥ng t√¨m th·∫•y!');
                        this.finalScore = document.getElementById('finalScore');
                        if (!this.finalScore) console.error('L·ªói: finalScore kh√¥ng t√¨m th·∫•y!');
                        this.finalAccuracy = document.getElementById('finalAccuracy');
                        if (!this.finalAccuracy) console.error('L·ªói: finalAccuracy kh√¥ng t√¨m th·∫•y!');
                        this.totalAttemptsModal = document.getElementById('totalAttempts');
                        if (!this.totalAttemptsModal) console.error('L·ªói: totalAttemptsModal kh√¥ng t√¨m th·∫•y!');
                        this.personalMessage = document.getElementById('personalMessage');
                        if (!this.personalMessage) console.error('L·ªói: personalMessage kh√¥ng t√¨m th·∫•y!');
                        this.overallMessage = document.getElementById('overallMessage');
                        if (!this.overallMessage) console.error('L·ªói: overallMessage kh√¥ng t√¨m th·∫•y!');
                        this.modalResetBtn = document.getElementById('modalResetBtn');
                        if (!this.modalResetBtn) console.error('L·ªói: modalResetBtn kh√¥ng t√¨m th·∫•y!');
                        this.modalBackToSelectionBtn = document.getElementById('modalBackToSelectionBtn');
                        if (!this.modalBackToSelectionBtn) console.error('L·ªói: modalBackToSelectionBtn kh√¥ng t√¨m th·∫•y!');
                    } else {
                        console.error('L·ªói: Kh√¥ng th·ªÉ truy c·∫≠p c√°c ph·∫ßn t·ª≠ con c·ªßa resultModal v√¨ resultModal l√† null.');
                    }
                } catch (e) {
                    console.error('L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o ph·∫ßn t·ª≠ DOM:', e);
                }
            }

            /**
             * Sets up event listeners for buttons and dropdown.
             */
            setupEventListeners() {
                this.loadBtn.addEventListener('click', () => this.loadPractice());
                this.startBtn.addEventListener('click', () => this.startGame());
                this.newGameBtn.addEventListener('click', () => this.resetGame(true)); // Pass true to indicate direct restart
                this.audioBtn.addEventListener('click', () => this.playCurrentWordAudio());
                this.toggleDisplayModeBtn.addEventListener('click', () => this.toggleDisplayMode()); // Event for mode toggle button
                
                if (this.modalResetBtn) { // Check if elements exist before adding listeners
                    this.modalResetBtn.addEventListener('click', () => this.resetGame(true)); // Pass true to indicate direct restart
                } else {
                    console.warn('C·∫£nh b√°o: modalResetBtn kh√¥ng t√¨m th·∫•y.');
                }
                if (this.modalBackToSelectionBtn) {
                    this.modalBackToSelectionBtn.addEventListener('click', () => this.backToSelection());
                } else {
                    console.warn('C·∫£nh b√°o: modalBackToSelectionBtn kh√¥ng t√¨m th·∫•y.');
                }

                // Close modal when clicking outside modal content
                if (this.resultModal) {
                    this.resultModal.addEventListener('click', (e) => {
                        if (e.target === this.resultModal) {
                            this.resultModal.style.display = 'none';
                            // Removed console.log for cleaner output
                        }
                    });
                }
            }

            /**
             * Initializes the practice selection interface: populates the dropdown.
             */
            initializePracticeSelector() {
                this.practiceDropdown.innerHTML = '<option value="">Ch·ªçn b√†i luy·ªán t·∫≠p...</option>';
                CONFIG.practices.forEach(practice => {
                    const option = document.createElement('option');
                    option.value = practice.id;
                    option.textContent = practice.name;
                    this.practiceDropdown.appendChild(option);
                });
                this.showElement(this.practiceSelector);
                this.hideElement(this.gameSection);
            }

            /**
             * Loads practice data from the file.
             */
            async loadPractice() {
                this.studentName = this.studentNameInput.value.trim();
                this.currentPracticeId = this.practiceDropdown.value;

                // Validate student name
                if (!this.studentName) {
                    this.showError('Vui l√≤ng nh·∫≠p t√™n h·ªçc sinh!');
                    this.studentNameInput.classList.add('error');
                    this.studentNameInput.focus();
                    return;
                }
                this.studentNameInput.classList.remove('error');

                // Validate practice selection
                if (!this.currentPracticeId) {
                    this.showError('Vui l√≤ng ch·ªçn m·ªôt b√†i luy·ªán t·∫≠p!');
                    return;
                }
                
                this.showLoading(true);
                this.hideError();

                try {
                    let fileContent;
                    let isUsingDemo = false;
                    
                    const txtPath = `${CONFIG.dataPath}${this.currentPracticeId}/${this.currentPracticeId}.txt`;
                    
                    try {
                        const response = await fetch(txtPath);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        fileContent = await response.text();
                    } catch (error) {
                        console.warn(`Kh√¥ng th·ªÉ t·∫£i t·ªáp t·ª´ ${txtPath}:`, error);
                        if (demoData[this.currentPracticeId]) {
                            fileContent = demoData[this.currentPracticeId];
                            isUsingDemo = true;
                        } else {
                            throw new Error(`Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho b√†i "${this.currentPracticeId}".`);
                        }
                    }

                    if (isUsingDemo) {
                        this.showError(`‚ö†Ô∏è ƒêang s·ª≠ d·ª•ng d·ªØ li·ªáu demo cho b√†i "${this.currentPracticeId}". ƒê·ªÉ d√πng file th·∫≠t, h√£y ƒë·∫∑t file t·∫°i: ${txtPath}`);
                        setTimeout(() => this.hideError(), 6000);
                    }
                    
                    this.allWords = this.parsePracticeData(fileContent);

                    if (this.allWords.length === 0) {
                        throw new Error('Kh√¥ng t√¨m th·∫•y t·ª´ h·ª£p l·ªá trong file b√†i h·ªçc!');
                    }
                    
                    // Select 9 random words with unique pinyins for the practice session
                    this.selectRandomPracticeWords(9);

                    this.showPracticeInfo();
                    this.showLoading(false);
                    this.startBtn.disabled = false; // Enable Start button
                    this.shufflePracticeWords(); // Shuffle practice words after selection
                    this.prepareAndRenderInitialGrid(); // Prepare initial pinyin grid
                    this.updateStats(); // Update initial stats
                    this.chineseTextDisplay.textContent = 'B·∫•m "B·∫Øt ƒë·∫ßu"';
                    this.meaningDisplay.textContent = 'ƒë·ªÉ ch∆°i';

                } catch (error) {
                    console.error('L·ªói khi t·∫£i b√†i luy·ªán t·∫≠p:', error);
                    this.showError(error.message);
                    this.showLoading(false);
                    this.startBtn.disabled = true; // Disable Start button on error
                }
            }

            /**
             * Parses practice data from a text string.
             * @param {string} dataString - Data string from the .txt file.
             * @returns {Array<Object>} Array of word objects.
             */
            parsePracticeData(dataString) {
                const lines = dataString.trim().split('\n');
                const parsedWords = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const parts = line.split('|');
                    // Expected structure: chinese|pinyin|meaning.
                    if (parts.length >= 3) { 
                        parsedWords.push({
                            chinese: parts[0].trim(),
                            pinyin: parts[1].trim(), // Get pinyin from the 2nd element
                            meaning: parts[2].trim()
                        });
                    } else {
                        console.warn(`D√≤ng ${i + 1} c√≥ ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng: ${line}. ƒê·ªãnh d·∫°ng mong mu·ªën: chinese|pinyin|meaning`);
                    }
                }
                return parsedWords;
            }

            /**
             * Selects a specified number of random words with unique pinyins for the practice session.
             * @param {number} count - The number of words to select.
             */
            selectRandomPracticeWords(count) {
                this.practiceWords = [];
                const availableWords = [...this.allWords]; // Create a copy to modify
                const selectedPinyins = new Set();

                // Shuffle available words to ensure randomness
                for (let i = availableWords.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableWords[i], availableWords[j]] = [availableWords[j], availableWords[i]];
                }

                for (let i = 0; i < availableWords.length && this.practiceWords.length < count; i++) {
                    const word = availableWords[i];
                    if (!selectedPinyins.has(word.pinyin)) {
                        this.practiceWords.push(word);
                        selectedPinyins.add(word.pinyin);
                    }
                }

                // If not enough unique pinyins, fill with duplicates (though the request implies unique pinyins)
                // This part ensures we always have 'count' words, even if pinyins are not strictly unique.
                // For this specific request, we prioritize unique pinyins first.
                // If there are fewer than 9 unique pinyins in the entire dataset, this will select all unique ones
                // and then stop. If the user strictly needs 9 words, even if pinyins are duplicated,
                // a different logic would be needed here.
                // For now, it will select up to 'count' words with unique pinyins.
                if (this.practiceWords.length < count) {
                    console.warn(`Kh√¥ng th·ªÉ t√¨m th·∫•y ${count} t·ª´ c√≥ pinyin kh√°c nhau. ƒê√£ ch·ªçn ${this.practiceWords.length} t·ª´ pinyin duy nh·∫•t.`);
                    // If you *must* have 9 words, even with duplicate pinyins, you could add logic here
                    // to pick remaining words randomly from 'allWords' without pinyin uniqueness check.
                    // For this request, we'll stick to the unique pinyin requirement as much as possible.
                }
            }


            /**
             * Displays information about the selected practice.
             */
            showPracticeInfo() {
                const practiceName = CONFIG.practices.find(p => p.id === this.currentPracticeId)?.name || this.currentPracticeId;
                this.practiceInfoDisplay.innerHTML = `
                    <strong>üë®‚Äçüéì H·ªçc sinh: ${this.studentName}</strong><br>
                    <strong>üìö ${practiceName}</strong><br>
                    S·ªë t·ª´ trong b√†i luy·ªán t·∫≠p: ${this.practiceWords.length}<br>
                    <div class="action-buttons">
                        <button class="action-btn start-game-btn" onclick="game.startGame()">
                            üéØ B·∫Øt ƒë·∫ßu
                        </button>
                    </div>
                `;
                this.showElement(this.practiceInfoDisplay);
            }

            /**
             * Shows/hides loading indicator.
             * @param {boolean} show - True to show, False to hide.
             */
            showLoading(show) {
                this.loadingIndicator.style.display = show ? 'block' : 'none';
                this.loadBtn.disabled = show;
                this.practiceDropdown.disabled = show;
                this.studentNameInput.disabled = show;
            }

            /**
             * Displays an error message.
             * @param {string} message - Error content.
             */
            showError(message) {
                this.errorDisplay.textContent = message;
                this.errorDisplay.style.display = 'block';
            }

            /**
             * Hides the error message.
             */
            hideError() {
                this.errorDisplay.style.display = 'none';
            }

            /**
             * Displays a DOM element.
             * @param {HTMLElement} element - Element to display.
             */
            showElement(element) {
                element.style.display = 'block';
            }

            /**
             * Hides a DOM element.
             * @param {HTMLElement} element - Element to hide.
             */
            hideElement(element) {
                element.style.display = 'none';
            }

            /**
             * Prepares data for the 9 initial pinyin cells and renders them.
             * These cells will be fixed throughout the game.
             */
            prepareAndRenderInitialGrid() {
                // Get unique pinyins from the selected 'practiceWords'
                let uniquePinyinsFromPractice = Array.from(new Set(this.practiceWords.map(word => word.pinyin)));
                
                // Shuffle these unique pinyins
                for (let i = uniquePinyinsFromPractice.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [uniquePinyinsFromPractice[i], uniquePinyinsFromPractice[j]] = [uniquePinyinsFromPractice[j], uniquePinyinsFromPractice[i]];
                }

                // Take the first 9 unique pinyins for the grid.
                // If there are fewer than 9 unique pinyins in practiceWords, we'll use what we have.
                const pinyinsForGrid = uniquePinyinsFromPractice.slice(0, 9);

                // If less than 9 unique pinyins are available, fill the remaining spots with duplicates
                // from the available unique pinyins to ensure 9 cells are always displayed.
                while (pinyinsForGrid.length < 9 && uniquePinyinsFromPractice.length > 0) {
                    pinyinsForGrid.push(uniquePinyinsFromPractice[Math.floor(Math.random() * uniquePinyinsFromPractice.length)]);
                }
                // If for some reason there are absolutely no pinyins, add placeholders
                while (pinyinsForGrid.length < 9) {
                     pinyinsForGrid.push(`pinyin${pinyinsForGrid.length + 1}`);
                }


                // Shuffle the grid pinyins one more time to randomize their display positions
                for (let i = pinyinsForGrid.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pinyinsForGrid[i], pinyinsForGrid[j]] = [pinyinsForGrid[j], pinyinsForGrid[i]];
                }


                this.gridPinyinCellsData = pinyinsForGrid.map(pinyin => ({
                    pinyin: pinyin, // This is the pinyin string for the cell
                    isHidden: false,
                    isCorrect: false
                }));

                this.renderPinyinGrid();
            }

            /**
             * Renders (or re-renders) the pinyin grid based on data in gridPinyinCellsData
             * and the current display mode.
             */
            renderPinyinGrid() {
                this.pinyinGridElement.innerHTML = ''; // Clear existing cells
                this.gridPinyinCellsData.forEach((cellData, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'pinyin-cell';
                    
                    if (cellData.isHidden) {
                        cell.classList.add('hidden'); // Add 'hidden' class to completely hide the cell
                    } else {
                        let displayText = '';
                        // Find a word in this.allWords that has the corresponding pinyin to get Chinese char and meaning
                        // (only need to find 1 word, for display purposes)
                        const correspondingWord = this.allWords.find(word => word.pinyin === cellData.pinyin);

                        switch (this.displayMode) {
                            case 'pinyin':
                                displayText = cellData.pinyin;
                                cell.style.fontFamily = 'Mulish, sans-serif'; // Ensure pinyin font
                                cell.style.fontSize = '18px'; // Default font size
                                break;
                            case 'meaning':
                                displayText = correspondingWord ? correspondingWord.meaning : 'N/A';
                                cell.style.fontFamily = 'Mulish, sans-serif'; // Ensure Vietnamese font
                                cell.style.fontSize = '16px'; // Smaller font size for meaning
                                break;
                            case 'chinese':
                                displayText = correspondingWord ? correspondingWord.chinese : 'N/A';
                                cell.style.fontFamily = 'Kaiti, sans-serif'; // Apply Chinese font
                                cell.style.fontSize = 'clamp(1.2em, 4vw, 2em)'; // Adjust font size for Chinese characters
                                break;
                            default:
                                displayText = cellData.pinyin;
                                cell.style.fontFamily = 'Mulish, sans-serif';
                                cell.style.fontSize = '18px';
                        }
                        cell.textContent = displayText;
                        // Only add event listener if the cell is not hidden
                        cell.addEventListener('click', () => this.selectCell(index)); 
                    }
                    this.pinyinGridElement.appendChild(cell);
                });
            }

            /**
             * Starts the game.
             */
            startGame() {
                if (this.practiceWords.length === 0) {
                    this.showError('Ch∆∞a c√≥ d·ªØ li·ªáu b√†i h·ªçc. Vui l√≤ng ch·ªçn b√†i h·ªçc tr∆∞·ªõc.');
                    return;
                }

                this.hideElement(this.practiceSelector);
                this.showElement(this.gameSection);

                this.gameStarted = true;
                this.startBtn.style.display = 'none'; // Hide "Start" button
                this.newGameBtn.style.display = 'none'; // Ensure "Play Again" button is also hidden
                this.currentWordIndex = 0; // Reset word index to 0
                this.score = 0;
                this.correctAnswers = 0;
                this.totalAttempts = 0;
                
                // Reset state of pinyin cells on the grid
                this.gridPinyinCellsData.forEach(data => {
                    data.isHidden = false;
                    data.isCorrect = false;
                });
                this.renderPinyinGrid(); // Re-render grid to show all cells

                this.updateStats(); // Update initial stats
                this.playCurrentWord(); // Start playing the first word
            }

            /**
             * Plays the current word.
             * Gets the current word and plays its audio.
             */
            playCurrentWord() {
                // Check if all words have been played, end game
                if (this.currentWordIndex >= this.practiceWords.length) {
                    this.endGame();
                    return;
                }

                this.isPlaying = true; // Set playing state
                const currentWord = this.practiceWords[this.currentWordIndex];
                
                // Reset font styles to default (Mulish) and remove specific classes first
                this.chineseTextDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.chineseTextDisplay.style.fontSize = ''; // Reset to default clamped size from CSS
                this.chineseTextDisplay.style.color = '#d32f2f'; // Default Chinese color
                this.chineseTextDisplay.classList.remove('pinyin-font'); // Remove specific pinyin font class
                
                this.meaningDisplay.style.fontFamily = 'Mulish, sans-serif'; // Corrected line
                this.meaningDisplay.style.fontSize = ''; // Reset to default clamped size from CSS
                this.meaningDisplay.style.color = '#666'; // Default meaning color
                this.meaningDisplay.style.fontStyle = 'italic'; // Default meaning style
                this.meaningDisplay.classList.remove('pinyin-font'); // Remove specific pinyin font class

                switch (this.displayMode) {
                    case 'pinyin':
                        // If grid displays Pinyin, current word section should display Chinese characters and Meaning
                        this.chineseTextDisplay.textContent = currentWord.chinese;
                        this.chineseTextDisplay.style.fontFamily = 'Kaiti, sans-serif';
                        this.chineseTextDisplay.style.fontSize = 'clamp(2em, 15vw, 3em)';
                        this.meaningDisplay.textContent = currentWord.meaning;
                        this.meaningDisplay.style.fontStyle = 'italic';
                        break;
                    case 'meaning':
                        // If grid displays Meaning, current word section should display Chinese characters and Pinyin
                        this.chineseTextDisplay.textContent = currentWord.chinese;
                        this.chineseTextDisplay.style.fontFamily = 'Kaiti, sans-serif';
                        this.chineseTextDisplay.style.fontSize = 'clamp(2em, 15vw, 3em)';
                        this.meaningDisplay.textContent = currentWord.pinyin;
                        this.meaningDisplay.classList.add('pinyin-font');
                        break;
                    case 'chinese':
                        // If grid displays Chinese characters, current word section should display Pinyin and Meaning
                        this.chineseTextDisplay.textContent = currentWord.pinyin;
                        this.chineseTextDisplay.classList.add('pinyin-font');
                        this.meaningDisplay.textContent = currentWord.meaning;
                        this.meaningDisplay.style.fontStyle = 'italic';
                        break;
                }
                
                // Play audio for the Chinese word (always plays Chinese characters)
                this.playCurrentWordAudio();
            }

            /**
             * Plays the audio for the current Chinese word.
             * Prioritizes MP3 file, falls back to Web Speech API on error.
             */
            async playCurrentWordAudio() {
                if (!this.gameStarted || !this.isPlaying) return;

                const currentWord = this.practiceWords[this.currentWordIndex];
                const audioFilePath = `${CONFIG.dataPath}${this.currentPracticeId}/mp3/${currentWord.chinese}.mp3`;

                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                }

                this.audioBtn.classList.add('playing');
                this.audioBtn.disabled = true;
                this.audioBtn.classList.remove('error');
                this.hideElement(this.audioStatus);

                try {
                    this.currentAudio = new Audio(audioFilePath);
                    this.currentAudio.volume = 1.0;
                    this.currentAudio.playbackRate = 0.8;

                    this.currentAudio.onended = () => {
                        this.audioBtn.classList.remove('playing');
                        this.audioBtn.disabled = false;
                    };

                    this.currentAudio.onerror = (e) => {
                        console.error('L·ªói t·ªáp √¢m thanh:', e);
                        this.audioBtn.classList.remove('playing');
                        this.audioBtn.classList.add('error');
                        this.audioBtn.disabled = false;
                        //this.showAudioStatus('Kh√¥ng t√¨m th·∫•y t·ªáp √¢m thanh. S·ª≠ d·ª•ng gi·ªçng ƒë·ªçc t·ªïng h·ª£p.', 'error');
                        this.speakText(currentWord.chinese); // Fallback to text-to-speech
                    };

                    await this.currentAudio.play();
                } catch (error) {
                    console.error('L·ªói khi ph√°t √¢m thanh (kh·ªëi catch):', error);
                    this.audioBtn.classList.remove('playing');
                    this.audioBtn.classList.add('error');
                    this.audioBtn.disabled = false;
                    //this.showAudioStatus('L·ªói khi ph√°t √¢m thanh. S·ª≠ d·ª•ng gi·ªçng ƒë·ªçc t·ªïng h·ª£p.', 'error');
                    this.speakText(currentWord.chinese); // Fallback to text-to-speech
                }
            }

            /**
             * Speaks text using the Web Speech API.
             * @param {string} text - Text to speak.
             */
            speakText(text) {
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel(); // Stop any ongoing speech
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'zh-CN'; // Set language to Chinese
                    utterance.rate = 0.8; // Speech rate
                    utterance.pitch = 1; // Speech pitch
                    speechSynthesis.speak(utterance);

                    utterance.onend = () => {
                        this.audioBtn.classList.remove('playing');
                        this.audioBtn.disabled = false;
                        this.audioBtn.classList.remove('error'); // Remove error state if TTS is successful
                    };
                    utterance.onerror = (e) => {
                        console.error('L·ªói chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i:', e);
                        this.audioBtn.classList.remove('playing');
                        this.audioBtn.classList.add('error');
                        this.audioBtn.disabled = false;
                        //this.showAudioStatus('Kh√¥ng th·ªÉ ph√°t √¢m thanh t·ªïng h·ª£p.', 'error');
                    };
                } else {
                    this.showAudioStatus('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Speech API.', 'error');
                    this.audioBtn.classList.remove('playing');
                    this.audioBtn.classList.add('error');
                    this.audioBtn.disabled = false;
                }
            }

            /**
             * Displays audio status.
             * @param {string} message - Message to display.
             * @param {string} type - Status type ('info', 'error').
             */
            showAudioStatus(message, type) {
                this.audioStatus.textContent = message;
                this.audioStatus.className = `audio-status ${type}`;
                this.showElement(this.audioStatus);
                setTimeout(() => this.hideElement(this.audioStatus), 3000);
            }

            /**
             * Handles user selection of a pinyin cell.
             * @param {number} selectedIndex - Index of the pinyin cell selected by the user in gridPinyinCellsData array.
             */
            selectCell(selectedIndex) { 
                // Ensure game is running and waiting for user selection
                if (!this.gameStarted || !this.isPlaying) return;
                
                const selectedCellData = this.gridPinyinCellsData[selectedIndex];
                const selectedCellElement = this.pinyinGridElement.children[selectedIndex];
                
                // If cell is already hidden, do nothing
                if (selectedCellData.isHidden) return;

                this.totalAttempts++;
                
                // Check if the selection is correct
                if (selectedCellData.pinyin === this.practiceWords[this.currentWordIndex].pinyin) { 
                    // If correct
                    selectedCellElement.classList.add('correct'); // Add 'correct' class to change color
                    this.score += 10; // Increase score
                    this.correctAnswers++; // Increase correct answer count
                    
                    // Update data state for the cell to be hidden
                    selectedCellData.isHidden = true;
                    selectedCellData.isCorrect = true;

                    // Disable all other pinyin cells to prevent double-clicking
                    this.disablePinyinGrid(true);
                    this.isPlaying = false; // Pause interaction

                    // Wait a bit then update cell and move to next word
                    setTimeout(() => {
                        selectedCellElement.classList.remove('correct'); // Remove 'correct' class
                        this.renderPinyinGrid(); // Re-render grid to update hidden state of cell
                        this.currentWordIndex++; // Move to the next word in the practiceWords array
                        this.disablePinyinGrid(false); // Re-enable grid
                        this.playCurrentWord(); // Play new word
                    }, 1000);
                } else {
                    // If incorrect
                    selectedCellElement.classList.add('incorrect'); // Add 'incorrect' class to change color and shake
                    // Only deduct points if current score is greater than 0
                    if (this.score > 0) { 
                        this.score = Math.max(0, this.score - 5); // Deduct 5 points but not below 0
                    }
                    // Remove 'incorrect' class after a delay
                    setTimeout(() => {
                        selectedCellElement.classList.remove('incorrect');
                    }, 1000);
                }
                
                // Update stats on the interface
                this.updateStats();
            }

            /**
             * Disables or enables the pinyin grid.
             * @param {boolean} disable - True to disable, False to enable.
             */
            disablePinyinGrid(disable) {
                const cells = this.pinyinGridElement.children;
                for (let i = 0; i < cells.length; i++) {
                    if (!this.gridPinyinCellsData[i].isHidden) { // Only disable cells that are not hidden
                        if (disable) {
                            cells[i].classList.add('disabled');
                        } else {
                            cells[i].classList.remove('disabled');
                        }
                    }
                }
            }

            /**
             * Updates statistics on the user interface.
             */
            updateStats() {
                this.scoreElement.textContent = this.score;
                this.progressElement.textContent = `${this.correctAnswers}/${this.practiceWords.length}`;
                
                // Calculate accuracy
                const accuracy = this.totalAttempts > 0 ? 
                    Math.round((this.correctAnswers / this.totalAttempts) * 100) : 0;
                this.accuracyElement.textContent = `${accuracy}%`;
                
                // Update progress bar
                const progressPercent = (this.correctAnswers / this.practiceWords.length) * 100;
                this.progressFillElement.style.width = `${progressPercent}%`;
            }

            /**
             * Toggles the display mode of pinyin cells (Pinyin, Meaning, Chinese).
             */
            toggleDisplayMode() {
                this.currentDisplayModeIndex = (this.currentDisplayModeIndex + 1) % this.displayModes.length;
                this.displayMode = this.displayModes[this.currentDisplayModeIndex];
                this.updateDisplayModeButtonText();
                this.renderPinyinGrid(); // Re-render grid with new mode
                // Update current word display to reflect new mode
                if (this.gameStarted && this.isPlaying) {
                    this.playCurrentWord(); 
                }
            }

            /**
             * Updates the text of the mode toggle button.
             */
            updateDisplayModeButtonText() {
                let buttonText = '';
                switch (this.displayMode) {
                    case 'pinyin':
                        buttonText = 'Ch·∫ø ƒë·ªô: Pinyin';
                        break;
                    case 'meaning':
                        buttonText = 'Ch·∫ø ƒë·ªô: Nghƒ©a';
                        break;
                    case 'chinese':
                        buttonText = 'Ch·∫ø ƒë·ªô: Ch·ªØ H√°n';
                        break;
                }
                this.toggleDisplayModeBtn.textContent = `‚öôÔ∏è ${buttonText}`;
            }

            /**
             * Ends the game when all words are completed.
             */
            endGame() {
                console.log('endGame() ƒë∆∞·ª£c g·ªçi. Tr√≤ ch∆°i ƒë√£ k·∫øt th√∫c.');
                this.gameStarted = false;
                this.isPlaying = false;
                this.chineseTextDisplay.textContent = 'Ho√†n th√†nh!';
                this.chineseTextDisplay.style.fontSize = 'clamp(1.5em, 15vw, 2em)';
                this.meaningDisplay.textContent = 'Tuy·ªát v·ªùi!';
                // Reset font styles for end game message
                this.chineseTextDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.chineseTextDisplay.style.fontSize = ''; 
                this.chineseTextDisplay.style.color = '#2c3e50'; 
                this.chineseTextDisplay.classList.remove('pinyin-font');
                this.meaningDisplay.style.fontFamily = 'Mulish, sans-serif'; // Corrected line
                this.meaningDisplay.style.fontSize = ''; 
                this.meaningDisplay.style.color = '#7f8c8d'; 
                this.meaningDisplay.style.fontStyle = 'normal'; 
                this.meaningDisplay.classList.remove('pinyin-font');

                this.startBtn.style.display = 'none'; // Hide "Start" button
                this.newGameBtn.style.display = 'inline-block'; // Show "Play Again" button
                
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.currentAudio = null;
                }

                this.attemptCount++; // Increment game completion count
                console.log('endGame: S·ªë l·∫ßn th·ª≠:', this.attemptCount);

                // Show result modal
                this.showResult();
            }

            /**
             * Displays the final game result modal.
             */
            showResult() {
                console.log('showResult() ƒë∆∞·ª£c g·ªçi. ƒêang chu·∫©n b·ªã hi·ªÉn th·ªã modal.');
                if (!this.resultModal) {
                    console.error('showResult: L·ªói: Kh√¥ng th·ªÉ hi·ªÉn th·ªã modal k·∫øt qu·∫£ v√¨ ph·∫ßn t·ª≠ resultModal l√† null. Vui l√≤ng ki·ªÉm tra l·∫°i initializeElements().');
                    return;
                }
                // console.log('showResult: resultModal ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n l√† t·ªìn t·∫°i.'); // Removed for cleaner output

                const accuracy = this.totalAttempts > 0 ? 
                    Math.round((this.correctAnswers / this.totalAttempts) * 100) : 0;
                
                if (this.resultTitle) {
                    this.resultTitle.textContent = this.studentName;
                    // console.log('showResult: resultTitle ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: resultTitle l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                if (this.finalScore) {
                    this.finalScore.textContent = this.score;
                    // console.log('showResult: finalScore ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: finalScore l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                if (this.finalAccuracy) {
                    this.finalAccuracy.textContent = `${accuracy}%`;
                    this.finalAccuracy.className = 'result-stat-value ' + 
                        (accuracy >= 80 ? 'accuracy-high' : 
                         accuracy >= 60 ? 'accuracy-medium' : 'accuracy-low');
                    // console.log('showResult: finalAccuracy ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: finalAccuracy l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }
                
                if (this.totalAttemptsModal) {
                    this.totalAttemptsModal.textContent = this.totalAttempts;
                    // console.log('showResult: totalAttemptsModal ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: totalAttemptsModal l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                if (this.finalAttemptCount) {
                    this.finalAttemptCount.textContent = this.attemptCount;
                    // console.log('showResult: finalAttemptCount ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: finalAttemptCount l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                const practiceName = CONFIG.practices.find(p => p.id === this.currentPracticeId)?.name || this.currentPracticeId;
                if (this.finalPracticeName) {
                    this.finalPracticeName.textContent = practiceName;
                    // console.log('showResult: finalPracticeName ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: finalPracticeName l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }
                
                let personalMsg = '';
                let overallMsg = '';

                if (accuracy >= 90) {
                    personalMsg = `Ch√∫c m·ª´ng ${this.studentName}! K·∫øt qu·∫£ xu·∫•t s·∫Øc!`;
                    overallMsg = 'üéâ B·∫°n ƒë√£ th√†nh th·∫°o pinyin c·ªßa b√†i n√†y!';
                } else if (accuracy >= 70) {
                    personalMsg = `T·ªët l·∫Øm ${this.studentName}! B·∫°n ƒëang ti·∫øn b·ªô!`;
                    overallMsg = 'üëç Kh√° t·ªët! H√£y ti·∫øp t·ª•c luy·ªán t·∫≠p ƒë·ªÉ ƒë·∫°t ƒëi·ªÉm cao h∆°n!';
                } else if (accuracy >= 50) {
                    personalMsg = `${this.studentName}, h√£y c·ªë g·∫Øng th√™m nh√©!`;
                    overallMsg = 'üìö C·∫ßn c·∫£i thi·ªán th√™m. H√£y √¥n t·∫≠p v√† th·ª≠ l·∫°i!';
                } else {
                    personalMsg = `${this.studentName}, ƒë·ª´ng n·∫£n l√≤ng!`;
                    overallMsg = 'üí™ C·∫ßn luy·ªán t·∫≠p nhi·ªÅu h∆°n. H√£y √¥n t·∫≠p k·ªπ v√† th·ª≠ l·∫°i!';
                }

                if (this.personalMessage) {
                    this.personalMessage.textContent = personalMsg;
                    // console.log('showResult: personalMessage ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: personalMessage l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                if (this.overallMessage) {
                    this.overallMessage.textContent = overallMsg;
                    // console.log('showResult: overallMessage ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.'); // Removed for cleaner output
                } else {
                    console.error('showResult: overallMessage l√† null, kh√¥ng th·ªÉ c·∫≠p nh·∫≠t.');
                }

                this.resultModal.style.display = 'flex'; // Show modal
                // console.log('showResult: Thu·ªôc t√≠nh display c·ªßa modal k·∫øt qu·∫£ ƒë∆∞·ª£c ƒë·∫∑t th√†nh flex.'); // Removed for cleaner output
                // console.log('showResult: Ph·∫ßn t·ª≠ resultModal cu·ªëi c√πng:', this.resultModal); // Removed for cleaner output
            }

            /**
             * Resets the game to its initial state to play again.
             * @param {boolean} directRestart - If true, starts the game immediately after reset.
             */
            resetGame(directRestart = false) {
                if (this.resultModal) {
                    this.resultModal.style.display = 'none'; // Hide result modal
                    // console.log('resetGame: resultModal ƒë√£ ƒë∆∞·ª£c ·∫©n.'); // Removed for cleaner output
                } else {
                    console.warn('resetGame: resultModal kh√¥ng t√¨m th·∫•y, kh√¥ng th·ªÉ ·∫©n.');
                }
                
                this.currentWordIndex = 0;
                this.score = 0;
                this.correctAnswers = 0;
                this.totalAttempts = 0;
                this.gameStarted = false;
                this.isPlaying = false;
                
                this.chineseTextDisplay.textContent = 'B·∫•m "B·∫Øt ƒë·∫ßu"';
                this.meaningDisplay.textContent = 'ƒë·ªÉ ch∆°i';
                // Reset font styles for initial message
                this.chineseTextDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.chineseTextDisplay.style.fontSize = ''; 
                this.chineseTextDisplay.style.color = '#2c3e50'; 
                this.chineseTextDisplay.classList.remove('pinyin-font');
                this.meaningDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.meaningDisplay.style.fontSize = ''; 
                this.meaningDisplay.style.color = '#7f8c8d'; 
                this.meaningDisplay.style.fontStyle = 'normal'; 
                this.meaningDisplay.classList.remove('pinyin-font');

                this.startBtn.style.display = 'inline-block'; // Show "Start" button
                this.newGameBtn.style.display = 'none'; // Hide "Play Again" button
                
                this.shufflePracticeWords(); // Shuffle practice words for new game
                this.prepareAndRenderInitialGrid(); // Prepare and re-render initial grid
                this.updateStats(); // Update stats to 0

                if (directRestart) {
                    this.startGame(); // Start the game immediately
                }
            }

            /**
             * Returns to the practice selection screen.
             */
            backToSelection() {
                if (this.resultModal) {
                    this.resultModal.style.display = 'none'; // Hide result modal
                    // console.log('backToSelection: resultModal ƒë√£ ƒë∆∞·ª£c ·∫©n.'); // Removed for cleaner output
                } else {
                    console.warn('backToSelection: resultModal kh√¥ng t√¨m th·∫•y, kh√¥ng th·ªÉ ·∫©n.');
                }
                this.hideElement(this.gameSection);
                this.showElement(this.practiceSelector);

                // Reset game state completely
                this.allWords = [];
                this.practiceWords = [];
                this.currentWordIndex = 0;
                this.score = 0;
                this.correctAnswers = 0;
                this.totalAttempts = 0;
                this.gameStarted = false;
                this.isPlaying = false;
                this.currentAudio = null;
                this.studentName = '';
                this.currentPracticeId = '';
                this.attemptCount = 0;
                this.gridPinyinCellsData = [];

                this.studentNameInput.value = '';
                this.practiceDropdown.value = '';
                this.hideElement(this.practiceInfoDisplay);
                this.hideError();
                this.startBtn.disabled = true; // Disable Start button
                this.chineseTextDisplay.textContent = 'B·∫•m "T·∫£i B√†i"';
                this.meaningDisplay.textContent = 'ƒë·ªÉ b·∫Øt ƒë·∫ßu';
                // Reset font styles for initial message
                this.chineseTextDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.chineseTextDisplay.style.fontSize = ''; 
                this.chineseTextDisplay.style.color = '#2c3e50'; 
                this.chineseTextDisplay.classList.remove('pinyin-font');
                this.meaningDisplay.style.fontFamily = 'Mulish, sans-serif';
                this.meaningDisplay.style.fontSize = ''; 
                this.meaningDisplay.style.color = '#7f8c8d'; 
                this.meaningDisplay.style.fontStyle = 'normal'; 
                this.meaningDisplay.classList.remove('pinyin-font');

                this.updateStats(); // Update stats to 0
                this.renderPinyinGrid(); // Clear pinyin grid
            }

            /**
             * Randomly shuffles the order of words in the this.practiceWords array.
             * Uses the Fisher-Yates shuffle algorithm.
             */
            shufflePracticeWords() {
                for (let i = this.practiceWords.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.practiceWords[i], this.practiceWords[j]] = [this.practiceWords[j], this.practiceWords[i]];
                }
            }
        }

        // Initialize game when the web page is loaded
        const game = new PinyinGame();

        // Optimize for touch devices
        function setupTouchOptimizations() {
            const addTouchFeedback = (element) => {
                element.addEventListener('touchstart', function() {
                    this.style.opacity = '0.8';
                }, { passive: true });
                
                element.addEventListener('touchend', function() {
                    this.style.opacity = '1';
                }, { passive: true });
                
                element.addEventListener('touchcancel', function() {
                    this.style.opacity = '1';
                }, { passive: true });
            };

            document.querySelectorAll('button, .pinyin-cell').forEach(addTouchFeedback);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            game.initializePracticeSelector(); // Ensure dropdown is populated on page load
            setupTouchOptimizations();
        });

        // Cleanup when page unloads
        window.addEventListener('beforeunload', function() {
            if (game.currentAudio) {
                game.currentAudio.pause();
            }
        });

        // Handle orientation change
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                window.scrollTo(0, 0);
            }, 100);
        });
    </script>
</body>
</html>
